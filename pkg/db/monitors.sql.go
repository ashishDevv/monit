// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: monitors.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createMonitor = `-- name: CreateMonitor :one
INSERT INTO monitors (
    user_id, 
    url, 
    interval_sec, 
    timeout_sec,
    latency_threshold_ms,
    expected_status,
    alert_email
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7
)
RETURNING id
`

type CreateMonitorParams struct {
	UserID             pgtype.UUID
	Url                string
	IntervalSec        int32
	TimeoutSec         int32
	LatencyThresholdMs int32
	ExpectedStatus     int32
	AlertEmail         pgtype.Text
}

func (q *Queries) CreateMonitor(ctx context.Context, arg CreateMonitorParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, createMonitor,
		arg.UserID,
		arg.Url,
		arg.IntervalSec,
		arg.TimeoutSec,
		arg.LatencyThresholdMs,
		arg.ExpectedStatus,
		arg.AlertEmail,
	)
	var id pgtype.UUID
	err := row.Scan(&id)
	return id, err
}

const getAllMonitorByUserID = `-- name: GetAllMonitorByUserID :many
SELECT id, user_id, url, alert_email, interval_sec, timeout_sec, latency_threshold_ms, expected_status, enabled, updated_at, created_at
FROM monitors
WHERE user_id = $1
ORDER BY updated_at
LIMIT $2
OFFSET $3
`

type GetAllMonitorByUserIDParams struct {
	UserID pgtype.UUID
	Limit  int32
	Offset int32
}

func (q *Queries) GetAllMonitorByUserID(ctx context.Context, arg GetAllMonitorByUserIDParams) ([]Monitor, error) {
	rows, err := q.db.Query(ctx, getAllMonitorByUserID, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Monitor
	for rows.Next() {
		var i Monitor
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Url,
			&i.AlertEmail,
			&i.IntervalSec,
			&i.TimeoutSec,
			&i.LatencyThresholdMs,
			&i.ExpectedStatus,
			&i.Enabled,
			&i.UpdatedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMonitor = `-- name: GetMonitor :one
SELECT id, user_id, url, alert_email, interval_sec, timeout_sec, latency_threshold_ms, expected_status, enabled
FROM monitors
WHERE id = $1 AND user_id = $2
`

type GetMonitorParams struct {
	ID     pgtype.UUID
	UserID pgtype.UUID
}

type GetMonitorRow struct {
	ID                 pgtype.UUID
	UserID             pgtype.UUID
	Url                string
	AlertEmail         pgtype.Text
	IntervalSec        int32
	TimeoutSec         int32
	LatencyThresholdMs int32
	ExpectedStatus     int32
	Enabled            bool
}

func (q *Queries) GetMonitor(ctx context.Context, arg GetMonitorParams) (GetMonitorRow, error) {
	row := q.db.QueryRow(ctx, getMonitor, arg.ID, arg.UserID)
	var i GetMonitorRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Url,
		&i.AlertEmail,
		&i.IntervalSec,
		&i.TimeoutSec,
		&i.LatencyThresholdMs,
		&i.ExpectedStatus,
		&i.Enabled,
	)
	return i, err
}

const getMonitorByID = `-- name: GetMonitorByID :one
SELECT id, user_id, url, alert_email, interval_sec, timeout_sec, latency_threshold_ms, expected_status, enabled
FROM monitors
WHERE id = $1
`

type GetMonitorByIDRow struct {
	ID                 pgtype.UUID
	UserID             pgtype.UUID
	Url                string
	AlertEmail         pgtype.Text
	IntervalSec        int32
	TimeoutSec         int32
	LatencyThresholdMs int32
	ExpectedStatus     int32
	Enabled            bool
}

func (q *Queries) GetMonitorByID(ctx context.Context, id pgtype.UUID) (GetMonitorByIDRow, error) {
	row := q.db.QueryRow(ctx, getMonitorByID, id)
	var i GetMonitorByIDRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Url,
		&i.AlertEmail,
		&i.IntervalSec,
		&i.TimeoutSec,
		&i.LatencyThresholdMs,
		&i.ExpectedStatus,
		&i.Enabled,
	)
	return i, err
}

const updateMonitorStatus = `-- name: UpdateMonitorStatus :execrows
UPDATE monitors
SET enabled = $2
WHERE id = $1 AND user_id = $3
`

type UpdateMonitorStatusParams struct {
	ID      pgtype.UUID
	Enabled bool
	UserID  pgtype.UUID
}

func (q *Queries) UpdateMonitorStatus(ctx context.Context, arg UpdateMonitorStatusParams) (int64, error) {
	result, err := q.db.Exec(ctx, updateMonitorStatus, arg.ID, arg.Enabled, arg.UserID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}
